# MySQL锁类型

- 全局锁
- 表级锁
- 行级锁

## 全局锁


```MySQL
// 上锁：
flush tables with read lock

// 解锁
unlock tables
```

>> 所有增删改操作都会被阻塞
>> 所有修改表结构的操作都会被阻塞

>> 应用场景:
备份数据库时候，只能读取数据，不能修改数据，这样会造成业务停滞，无法更新数据

>> 解决方法
在支持
使用MVCC中的Read View，在备份时开启快照，备份时的数据是快照的数据，数据进行修改不会影响备份的数据


## 表级锁

>> 表级锁有哪些？
- 表锁
- MDL锁
- 意向锁
- AUTO-INC锁(自增主键锁)

### 表锁
```MySQL
// 加上读锁 只能读 共享锁
lock tables [table_name] read;
 
// 加上写锁 独占锁
lock tables [table_name] write;

unlock tables;
```


### MDL锁

当进行CRUD操作时加的是MDL读锁
当进行表结构修改时加的是MDL写锁

MDL锁不需要我们进行命令操作，数据库会自动执行

MDL锁直到事务结束后才自动释放

多个事务执行会自动加上锁，申请的锁会形成一个队列，写锁优先级比读锁优先级更高，一旦出现MDL写锁进行等待，后续的CRUD操作都会被阻塞

### 意向锁

>> 上锁时机
这个是在插入、更新、删除语句的时候需要先在表上加上意向独占锁，再在记录上加上独占锁

>> 意向锁特点
意向锁之间不会冲突，表级别的意向锁不会和行级别的锁产生冲突，只会和表级别的锁产生冲突

>> 意向锁作用
作用是，在加上表级别锁时不用遍历全部记录是否存在独占锁，加快处理速度

>> 没有意向锁时为什么要遍历全表记录?
因为当加上表级别锁的时候，通常是进行全表的操作(更新或删除),如果其他事务进行了一些操作导致行级锁，出现并发情况


### AUTO-INC锁(特殊的表级锁)

>> 作用是什么?
保证自增主键的唯一性和顺序性

>> 两种上锁模式
通过innodb_autoinc_lock_mode参数进行设置
三种参数：
> =0：默认使用传统模式
> =1: 混合使用连续模式
> =2: 
- 传统模式：对于每个Insert语句，InnoDB都会在整个表上获取一个AUTO-INC锁,
- 连续模式：对于单个Insert语句，仍然使用Innodb表级锁，但是对于批量插入语句，InoDB会使用AUTO-INC锁来保护分配自增值区间，当分配好自增区间后就释放AUTO-INC锁



## 行级锁

>> 行级锁有哪些?

- Record Lock: 记录锁 区分S锁和X锁
- Gap Lock: 间隙锁 存在于可重复读隔离级别
- Next-Key Lock: 临建锁

S锁：读锁，S锁之间兼容，S锁与X锁互斥
X锁：写锁，X锁之间互斥，X锁与S锁互斥
