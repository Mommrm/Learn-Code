## AOF日志

## RDB快照
简单介绍：在Redis执行写命令时，成功后把该命令写入日志文件

好处：
- 因为只有执行成功才会写入日志文件，减少检查写入日志的命令是否正确的开销
- 不会阻塞当前写操作命令的执行

缺点：
- 因为写操作和把命令写入日志文件是两个步骤，当在中间发生Redis宕机时，就会发生数据丢失
- 可能会给下一条写操作造成阻塞，因为执行命令和写入日志两个操作都是在主进程来完成的，如果将日志内容写入服务器硬盘时，出现I/O流压力过大，就会导致写硬盘速度慢，导致下一条写操作的阻塞

### 三种写回策略

因为上面的缺点都是写入硬盘的时机导致的发生的，因此有三种写回策略来解决这些问题

### 先引入Redis写入AOF日志的过程：
1. 执行写操作命令
2. 命令追加到server_aof_buf缓冲区
3. I/O系统调用write() （用户态转换为核心态)
4. 内核缓冲区page_cache
5. 由内核发起写操作
6. 硬盘写入


### 三个阶段：
- Redis执行完操作命令，把命令追加到server_aof_buf缓冲区
- 通过系统调用write()把server_aof_buf缓冲区的内容写入AOF日志文件，此时还未把AOF日志写入硬盘，而是拷贝到了内核缓冲区page_cache
- 内核缓冲区根据策略来决定什么时候写入到硬盘

### 三种策略:
在redis.conf文件中，appendfsync配置项可以有三个参数可以填写：
- Always: 执行完写操作就同步把AOF日志文件写入硬盘
- Everysec: 执行完写操作后，每秒把内核缓冲区的内容写入到硬盘
- No: 不由Redis控制写入硬盘的时机，交由操作系统来决定什么时候把内核缓冲区的内容写入硬盘


### 选择：
- Always: 最安全
- No: 性能最高，但是数据丢失风险大
- Everysec: 折中方案

### 深入底层
三种策略底层就是fsync()函数控制调用时机

- Always: 就是每次写入AOF日志后就执行一次fsync()函数
- No：永远不执行fsync()函数
- Everysec: 开启异步任务来执行fsync()函数

## AOF重写机制

AOF日志是一个文件，随着执行的命令越来越多，文件会越来越大，这就会导致性能问题，而解决这个问题就需要AOF重写机制，来压缩文件

### 重写机制

读取数据库中所有的键值对，然后每一个键值对用一条命令去记录到*新的AOF文件*，等到全部记录完毕，就把新的AOF文件替换原来的AOF文件
(就是读取最新的键值对，然后把最新的键值对的写操作记录到新的AOF文件中，这样就达到不用记录旧键值对的写命令，减少文件大小来达到压缩文件的目的)

如果在这个过程中，重写失败了，就删除这个新的AOF文件，然后继续使用旧的AOF文件

## AOF后台重写

因为上面的AOF重写机制，我们可以得知，重写是要把数据库中所有的键值对都拿出来，并生成对应的写命令，这是非常耗时的，为了解决这个问题，我们需要在后台完成这个重写操作


### 后台重写过程
主线程通过fork()系统调用创建一个子进程bgrewriteaof(注意注意这里是进程，如果是线程的话，会共享进程的数据导致一系列共享数据的问题)，然后这个时候主进程和子进程已经共享物理内存，然后子进程会通过读物理内存得到键值对，执行重写操作，如果在重写的时候，主进程执行了写操作，这个时候会出现时写复制(只会复制主进程修改的物理内存数据)，就是说子进程不知道已经执行了写操作，这个时候会引入AOF缓冲区和AOF重写缓冲区，把重写过程中主进程执行的写操作写入两个缓冲区，等到AOF重写完成，向主进程发送异步信号，主进程接收到之后会把AOF重写缓冲区中所有内容追加到新的AOF文件中，使得新旧两个AOF文件所保存的数据库状态一致，并把新的AOF文件进行改名，覆盖旧的AOF文件

操作系统会把主线程的页表复制一份给子进程，
页表记录着虚拟地址和物理地址的映射关系，通过页表的映射关系一样可以找到数据，但是页表对应的物理内存权限只有读，当父进程或者子进程发起写操作时，CPU会触发写保护中断(由违反权限导致的)，然后才会写中断处理函数中进行物理内存的复制(父子都有的页表)，然后重新设置其内存映射关系，将父子进程的内存读写权限设置为可读写，最后才会对内存进行写操作，这个过程称为写时复制


## 总结

> 持久化AOF技术说白了就是把写操作成功后把命令写入AOF文件中的过程

> 但是AOF文件要写入硬盘才能完成持久化，而写入硬盘的时机会导致两个问题，一个是数据丢失问题，一个是耗时问题阻塞主进程

> 为了解决这两个问题，引入了三种策略，其中是最安全的策略Always，每次写操作完成后立马调用fsync()去写入硬盘，然后是性能最好的No策略，永远不调用fsync()，由操作系统决定写回磁盘，最后是折中策略，Everysec策略，每隔一秒调用fsync()，写入硬盘。

> 又因为AOF文件是一个文件，每次写入会导致文件大小过大，此时为了压缩文件，引入了AOF重写机制，就是把数据库中所有的数据读取，并为之生成最新的写操作命令，不需要保存历史的写操作命令，达到节省空间的效果

> 而这个重写是十分耗时的，不可能在主进程来完成，这是会创建一个bgrewriteaof子进程来完成这个问题，然后为了解决这个主子进程的数据共享问题，会调用fork()复制主进程的页表(一个映射物理内存的表)，且权限为读的页表

> 这个时候也会出现问题，当子进程进行重写时，主进程并不会出现阻塞，此时主进程执行了写操作的话，会导致子进程数据不一致，此时引入了AOF重写缓冲区和AOF缓冲区，当子进程重写完毕之后，会发送一个信息给主进程，主进程会把AOF重写缓冲区的内容追加到新的AOF文件中，并修改新的AOF文件来覆盖旧的AOF文件。

