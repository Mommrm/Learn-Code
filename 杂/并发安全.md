## Java内存模型（JMM）
Java内存模型定义了多线程程序中变量的访问规则，以及如何在不同的线程之间共享数据。它包括主内存、工作内存的概念，以及变量的可见性、原子性、有序性保证。通过JMM，Java确保了在多线程环境下程序的正确执行，防止数据不一致等问题。

## 线程安全问题理解
线程安全问题指的是在多线程环境下，由于多个线程同时访问和修改共享资源，如果没有适当的同步控制，会导致数据不一致、脏读、死锁等问题。解决线程安全问题通常需要通过加锁、同步、使用原子操作等方式，确保同一时间只有一个线程可以修改共享资源，或者保证操作的原子性、可见性、有序性。

## Java保证多线程执行安全
Java通过以下机制保证多线程执行安全：

Synchronized关键字：提供内置的锁机制，保证同一时刻只有一个线程可以执行特定的代码块或方法。
volatile关键字：确保变量的修改对其他线程立即可见，常用于状态标记。
Atomic包下的原子类：提供无锁的线程安全操作，如AtomicInteger。
Lock接口及其实现类：如ReentrantLock，提供更灵活的锁机制。
并发容器：如ConcurrentHashMap，内部实现线程安全。

## Synchronized关键字底层原理
Synchronized通过监视器锁（Monitor）实现，主要有两种形式：对象锁和类锁。在字节码层面，通过monitorenter和monitorexit指令实现。对于对象锁，每个对象都有一个关联的监视器锁，当线程进入同步代码块或方法时，会尝试获取锁，成功则执行，失败则阻塞。类锁则是针对类的Class对象进行锁定。

## 锁机制升级
在Java中，尤其是JDK 1.6以后，Synchronized引入了偏向锁、轻量级锁、重量级锁的锁升级机制，以适应不同场景下的性能需求：

偏向锁：大多数情况下，锁仅被一个线程访问，偏向锁尽量减少同步开销。
轻量级锁：当有第二个线程尝试获取锁时，偏向锁升级为轻量级锁，通过自旋等待来避免线程阻塞。
重量级锁：当自旋等待超过一定次数或有更多线程竞争时，升级为重量级锁，此时未获取到锁的线程将被阻塞。

## Synchronized与Lock区别
灵活性：Lock接口提供了更多的锁操作，如尝试获取锁、超时获取锁、可中断获取锁等，比Synchronized更灵活。
公平性：Lock可以设置为公平锁或非公平锁，而Synchronized默认是非公平的。
性能：在低竞争下，Lock由于避免了不必要的上下文切换，性能可能优于Synchronized；高竞争下，两者性能相近。
范围：Synchronized既可以用于方法也可以用于代码块，Lock只能用于代码块。

## volatile关键字理解
volatile关键字保证了变量的可见性和禁止指令重排序。当一个变量被声明为volatile时，任何线程对它的修改都会立即刷新到主内存，其他线程读取时也会直接从主内存中读取最新值，保证了多线程环境下的可见性。同时，volatile还能防止编译器和处理器对指令的重排序，以保证程序的正确性。

## Synchronized与volatile区别
功能：volatile只能保证可见性和防止指令重排序，不能保证原子性；而Synchronized既能保证可见性也能保证原子性。
使用场景：volatile适用于状态标记等简单场景；Synchronized适用于需要互斥访问的复杂场景。

## AQS（AbstractQueuedSynchronizer）
AQS是Java并发包中的一个抽象类，为实现依赖于先进先出（FIFO）等待队列的阻塞锁和相关同步器（信号量、事件等）提供了一个框架。它维护了一个双向链表来管理等待线程，通过状态值来控制同步状态，支持独占模式和共享模式的锁。

## CAS（Compare And Swap）
CAS是CPU硬件层面支持的一种无锁算法，用于在多线程环境下实现原子操作。其过程是：首先比较内存中的值与预期值是否相等，如果相等则更新为新值，否则不更新。整个过程是原子的，避免了传统锁的开销。

## 乐观锁与悲观锁
悲观锁：假定最坏情况，认为每次操作都会发生冲突，因此在操作之前先加锁，阻止其他线程访问。如传统的锁机制。
乐观锁：假定最好的情况，不直接加锁，而是通过版本号、时间戳等机制来判断数据是否被其他线程修改过，适用于多读少写的场景。

## ReentrantLock实现原理
ReentrantLock是基于AQS实现的一个可重入的互斥锁。它通过内部的State状态来记录锁的持有情况，以及通过FIFO等待队列来管理等待的线程。当线程尝试获取锁时，如果当前状态为0，则通过CAS操作尝试将状态设置为1，获取锁成功；否则，线程将被封装成Node节点加入到等待队列中，并通过自旋、阻塞、唤醒等机制来管理线程的等待和唤醒。

## ReentrantLock与Synchronized区别
可中断性：ReentrantLock可以使用lockInterruptibly()方法实现可中断的等待，而Synchronized不可中断。
公平性选择：ReentrantLock可以设置为公平锁或非公平锁，Synchronized默认是非公平的。
尝试获取锁：ReentrantLock提供了尝试获取锁的方法，如tryLock()，Synchronized没有直接提供。
性能：在某些场景下，ReentrantLock由于更高的灵活性和更细粒度的控制，性能可能优于Synchronized。

## ConcurrentHashMap
ConcurrentHashMap是线程安全的哈希映射，它在Java 8中进行了重大改进，使用了分段锁（Segment）机制转变为基于CAS的节点+CAS+锁的组合策略，进一步提高了并发性能。它将数据分成多个Segment，每个Segment相当于一个小型的哈希表，可以独立进行锁操作，大大减少了锁的竞争。Java 8之后，它使用了更加精细的锁粒度（Node内部的CAS操作）和红黑树来优化性能。 