## 为什么使用线程池？
使用线程池的主要原因包括：

资源复用：线程创建和销毁的开销较大，线程池可以重用已创建的线程，减少创建和销毁线程的开销。
提高响应速度：当任务到达时，线程池可以立即分配线程执行任务，无需等待线程创建。
管理控制：线程池可以控制最大并发数，避免过多线程导致的资源耗尽。
易于扩展：线程池提供了统一的接口进行线程管理，便于扩展和维护。 

## 创建线程池时的核心参数和线程池执行原理
核心参数包括：

corePoolSize：核心线程数，线程池创建时初始化的线程数。
maximumPoolSize：最大线程数，线程池能容纳的最大线程数。
keepAliveTime：空闲线程存活时间，超过这个时间后，如果线程池中的线程数大于核心线程数，多余的线程会被终止。
unit：keepAliveTime的时间单位。
workQueue：任务队列，用于存放等待执行的任务。
threadFactory：线程工厂，用于创建新线程。
handler：拒绝策略，当线程池和队列都满时，如何处理新来的任务。

## 线程池执行原理：

当任务到来时，若线程池中线程数小于核心线程数，直接创建新线程执行任务。
若线程数等于核心线程数，任务进入队列等待。
若队列满且线程数小于最大线程数，创建新线程执行任务。
若队列满且线程数达到最大，触发拒绝策略。

## 线程池的拒绝策略
AbortPolicy：默认策略，直接抛出RejectedExecutionException异常。
CallerRunsPolicy：调用者所在线程执行任务。
DiscardPolicy：直接丢弃任务，不执行也不抛出异常。
DiscardOldestPolicy：丢弃队列中最旧的任务，并尝试重新提交当前任务。

## 常用的阻塞队列
ArrayBlockingQueue：基于数组的有界阻塞队列，先进先出。
LinkedBlockingQueue：基于链表的阻塞队列，可选是否设置容量上限。
PriorityBlockingQueue：具有优先级的无界阻塞队列。
SynchronousQueue：不存储元素的阻塞队列，每个插入操作必须等待另一个线程的移除操作。
ArrayBlockingQueue和LinkedBlockingQueue的区别
容量限制：ArrayBlockingQueue有固定的容量大小，而LinkedBlockingQueue可以设置为无界队列（默认）。
内部结构：ArrayBlockingQueue基于数组实现，而LinkedBlockingQueue基于链表实现。
性能：对于有界的队列，ArrayBlockingQueue在插入和移除操作上通常比LinkedBlockingQueue更快，因为数组的索引访问更快。

## 阻塞队列的作用
阻塞队列在生产者消费者模式中起到关键作用，它允许线程在队列为空时等待数据，或在队列满时等待空间，从而实现了线程间的同步。

## 为什么不先创建救急线程而是先把任务添加到阻塞队列中？
优先使用阻塞队列可以避免不必要的线程创建开销，减少系统资源消耗。只有当队列满且线程数未达到最大时，才会考虑创建新的线程。这样设计是为了更好地控制并发数，提高系统效率和稳定性。

## 常见的线程池种类
FixedThreadPool：固定大小线程池，线程数固定，适合执行大量短小任务。
CachedThreadPool：缓存线程池，线程数无上限，适合执行很多短期异步任务。
ScheduledThreadPool：定时任务线程池，支持定时及周期性任务执行。
SingleThreadExecutor：单线程线程池，确保所有任务顺序执行。

## 如何确定核心线程数和最大线程数？
核心线程数：通常根据系统的CPU核心数来设定，因为过多的线程会导致上下文切换开销增大。
最大线程数：需要考虑系统资源限制、任务性质（CPU密集型还是IO密集型）、期望的响应时间和吞吐量等因素。对于IO密集型任务，可以设置得更大，因为线程在等待IO时不会占用CPU；对于CPU密集型任务，则不宜设置过大，以免过度竞争CPU资源。实践中往往需要通过压力测试来调整这些参数以达到最优配置。

